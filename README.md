# NumLA — Lab 2. Разреженное хранение и FFT

## Преамбула

Вычислительные методы алгебры — это история о борьбе с ограничениями технологий, что можно, конечно, сказать про любые алгоритмы. Моделирование реальных процессов и не только нередко порождает СЛАУ огромных размеров, часто оказывается так, что матрицы, соответствующие этим системам, заполнены нулями, которые не влияют на уравнения, но в случае записи их в компьютер бесцельно занимают драгоценную память. Первой задачей для вас сегодня будет решение данной проблемы. Обратите особое внимание на оптимальность реализации, в дальнейших работах классы разреженных матриц будут активно использоваться.

Преобразование Фурье -- фундаментальный алгоритм, а области его применения крайне важны для жизни. **Discrete Fourier transform (DFT)** -- дискретная версия этого преобразования. Второй задачей на сегодня для вас будет реализация применения линейного оператора DFT за время меньшее, чем квадратичное по размерности. 

## Классы SparseMatrix
В этой части необходимо реализовать класс `SparseMatrixCSR` и `SparseMatrixCSC` для матриц `M ∈ Mat(n, m)` в форматах **Compressed Sparse Row** и **Compressed Sparse Column**.  
За `nnz` будем обозначать число ненулевых элементов в матрице. Все операции в классах должны быть реализованы оптимально, согласно теории, относительно `nnz`.

---

### Хранение

#### CSR (Compressed Sparse Row)

1. **Основные массивы**
   - `data` — значения ненулевых элементов.
   - `col` — номера столбцов для каждого элемента из `data`.
   - `row_ptr` — указатели на начало строк в массивах `data` и `col`.

2. **Инварианты**
   - Для каждой строки `i` ненулевые элементы хранятся в срезе `[row_ptr[i], row_ptr[i+1])`.
   - Внутри строки номера столбцов (`col`) отсортированы по возрастанию.
   - Явных нулей в `data` быть не должно.
   - Перевод в плотный формат внутри операций недопустим.

#### CSC (Compressed Sparse Column)

1. **Основные массивы**
   - `data` — значения ненулевых элементов.
   - `row` — номера строк для каждого элемента из `data`.
   - `col_ptr` — указатели на начало столбцов в массивах `data` и `row`.

2. **Инварианты**
   - Для каждого столбца `j` ненулевые элементы хранятся в срезе `[col_ptr[j], col_ptr[j+1])`.
   - Внутри столбца номера строк (`row`) отсортированы по возрастанию.
   - Явных нулей в `data` быть не должно.
   - Перевод в плотный формат внутри операций недопустим.

---

### Конструктор

- Принимает экземпляр класса `Matrix` и строит представление в соответствующем формате.
- Допускается реализация дополнительных методов построения: построение по трём массивам, удовлетворяющим инвариантам.

### Методы

#### Специальные 

- `nnz()` -- возвращает число ненулевых элементов. 
- `to_dense()` -- возвращает плотную матрицу класса `Matrix`.

#### Наследие `Matrix`
Классы должны реализовывать почти все методы, описанные в классе `Matrix`. 

Пройдёмся подробнее по особенностям: 
- Для разреженных не нужны:  `operator*` для **умножения матриц**, `det()`, `inv()`, `cond_number()`, `set()`. 
- `operator*` умножения вектора `Vector` на матрицу, возвращает `Vector`. Остальные операции с матрицей оставляют результат внутри класса.
- Классы должны поддерживать `norm_frobenius()` и одну из двух {1, inf}-норм, являющуюся удобной для вычисления в данном формате.
- В реализациях некоторых методов допустим и приветствуется перевод `CSR` ↔ `CSC`, указывайте, какой формат возвращает метод.

Поддержка остальных операций в рамках конкретного класса (`CSR` º `CSR`, `CSC` º `CSC`) должна сохраняться.

### Метрики Matrix vs SparseMatrix

Проведите бенчмарки операций, скорости и памяти, затрачиваемых матрицами. Сгенерируйте достаточно большие выборки матриц разных размеров, разной плотности и проведите анализ поведения написанных классов на типичных операциях.  

## Fast Fourier transform

_**Задача проста, задача одна: отправляй векторы туда-сюда**_. 

Обозначим за **F** оператор дискретного преобразования Фурье. Реализуйте применение **F** и **F**<sup>-1</sup> через алгоритм быстрого преобразования -- `FFT`. **F**{u}, где u — экземпляр класса `Vector`, возвращает `Vector` u_hat; **F**{u_hat} возвращает u. Применение **F** к классу `Matrix` трактуется как применение быстрого преобразования Фурье к вектор-столбцам матрицы и возвращает матрицу из вектор-столбцов результатов.

Формально:

#### Векторы
- `fft(Vector u) -> Vector`
- `ifft(Vector u_hat) -> Vector`

#### Матрицы
- `fft(Matrix A) -> Matrix`
- `ifft(Matrix A_hat) -> Matrix`

Так как **F** : ℂ<sup>n</sup> → ℂ<sup>n</sup>, модифицируйте классы `Matrix` и `Vector` для поддержки комплексного поля.

---

### Свёртки

Проведите эксперименты и убедитесь в корректности тождества **F** относительно свёртки: **F**{u $\star$ v} = **F**{u} **F**{v}.

Как известно из курса линейной алгебры, полиномы можно описывать векторами. Напишите небольшую программу для быстрого умножения полиномов p, q ∈ ℝ[t]. Проверьте корректность программы через наивную реализацию свёртки.

---

### Number-theoretic transform

Оператор **F** можно определить не только над комплексным полем, но и над произвольным кольцом с единицей, в котором есть специальный корень из единицы `omega`. Полезной оказывается работа с конечными полями **GF**(p<sup>q</sup>) с применением `FFT`, где `p` — простое.

Реализуйте операторы:

- `ntt(Vector r, uint p, uint omega) -> Vector`
- `intt(Vector r_hat, uint p, uint omega) -> Vector`

Мы полагаем контракт, что передаются `p` и `omega`, удовлетворяющие требованиям применения **F** над конечным полем **GF**(p) = ℤ/p. 

Протестируйте данную модифицированную реализацию `FFT` на свёртках полиномов над конечным полем. Проверьте корректность программы. 
